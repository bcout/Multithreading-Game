/********************************************************************
    Module: bullet.h
    Author: Brennan Couturier

    Functions to manage bullet data
********************************************************************/

#ifndef BULLET_H
#define BULLET_H

#define BULLET_ANIM_FRAMES 1
#define BULLET_ANIM_TICKS 50
#define BULLET_WIDTH 1
#define BULLET_HEIGHT 1

#include <stdbool.h>
#include <pthread.h>

extern char* PLAYER_BULLET_GRAPHIC[BULLET_ANIM_FRAMES][BULLET_HEIGHT];
extern char* ENEMY_BULLET_GRAPHIC[BULLET_ANIM_FRAMES][BULLET_HEIGHT];
/********************************************************************
Keep track of important bullet data
    col, row: The current location of the bullet
********************************************************************/
typedef struct bullet_struct{
    int col;
    int row;
    pthread_t thread;
    pthread_mutex_t mutex;
} bullet;

/********************************************************************
Allocate a bullet on the heap
********************************************************************/
bullet* create_bullet();

#endif/********************************************************************
    Module: enemy.h
    Author: Brennan Couturier

    Functions to manage caterpillar data
********************************************************************/

#ifndef CATERPILLAR_H
#define CATERPILLAR_H

/********************************************************************
Keep track of important caterpillar data
    col, row: Where the caterpillar currently is, measured at the head
********************************************************************/
typedef struct caterpillar_struct{
    int col;
    int row;
    int size;
} caterpillar;

/********************************************************************
Creates a new caterpillar of a given size
********************************************************************/
caterpillar* create_caterpillar(int start_col, int start_row, int size);

/********************************************************************
Draws an empty space where the caterpillar currently is then draws
    a caterpillar at the new location
********************************************************************/
void move_caterpillar(caterpillar* c, int dest_col, int dest_row);

#endif/**********************************************************************
  Module: console.h
  Author: Daniel Rea

  Purpose: Draw 2d images on the screen.  Also, draw main game image.

  NOTES: none of these functions are re-entrant (they are not thread
	 		safe)
**********************************************************************/

#ifndef CONSOLE_H
#define CONSOLE_H
#define _GNU_SOURCE

#include <stdbool.h>

/**************** DRAWING **************************/

/* directions in terms of deltas in x / y dimension */
#define LEFT -1
#define RIGHT 1
#define UP -1
#define DOWN 1

#define SCR_LEFT 0
#define SCR_TOP 0

/* Initialize curses, draw initial gamescreen. Refreshes console to terminal. 
 Also stores the requested dimensions of the consoe and tests the terminal for the
 given dimensions.*/
extern bool consoleInit(int reqHeight, int reqWidth, char *image[]);

/* Draws 2d `image' of `height' rows, at curses coordinates `(row, col)'.
   Note: parts of the `image' falling on negative rows are not drawn; each
   row drawn is clipped on the left and right side of the game console (note
   that `col' may be negative, indicating `image' starts to the left of the
   screen and will thus only be partially drawn. Useful for objects that are
   half off the screen  */
extern void consoleDrawImage(int row, int col, char *image[], int height);

/* Clears a 2d `width'x`height' rectangle with spaces.  Upper left hand
   corner is curses coordinate `(row,col)'. */
extern void consoleClearImage(int row, int col, int height, int width);

/* Moves cursor to bottom right corner and refreshes. If this is not done,
   the curses internal buffer (that you have been drawing to) is not dumped
   to screen. */
extern void consoleRefresh(void);

/*  turns off all updates. Can be used to prevent the screen refresh from working, e.g., at game end while threads are all catching up.*/
extern void disableConsole(int disabled);

/* Terminates curses cleanly. */
extern void consoleFinish(void);

/* Puts the given banner in the center of the screen */
void putBanner(const char *);

/* Draws the given string at the given location  */
void putString(char *, int row, int col, int maxlen);

/* Sleeps the given number of 20ms ticks */
void sleepTicks(int ticks);

/* clears the input buffer and then waits for one more key */
void finalKeypress();

/* gets a timespec that represents the time of one tick */
struct timespec getTimeout(int ticks);

#endif /* CONSOLE_H */
/********************************************************************
    Module: game_globals.h
    Author: Brennan Couturier

    Variables used throughout the program
********************************************************************/

#ifndef GAME_GLOBALS_H
#define GAME_GLOBALS_H

#include "lists.h"
#include "player.h"
#include "game_space.h"

#define GAME_COLS 80
#define GAME_ROWS 24
#define PLAYER_START_ROW 18
#define PLAYER_START_COL 20
#define PLAYER_START_LIVES 5
/********************************************************************
Keep track of the beginning of the caterpillar and bullet lists
********************************************************************/
extern caterpillar_node* caterpillar_list_head;
extern bullet_node* bullet_list_head;
extern thread_node* thread_list_head;


/********************************************************************
The visual representation of the player
********************************************************************/
extern char* PLAYER_GRAPHIC[PLAYER_ANIM_FRAMES][PLAYER_HEIGHT];

/********************************************************************
Give everyone access to the player object, use mutexes to control access
********************************************************************/
extern player* player_ref;

/********************************************************************
The condition variable the main thread waits on after creating
    and starting up the game's many threads
********************************************************************/
pthread_cond_t game_cond;

/********************************************************************
A variable checked by every thread to see if they should still run
********************************************************************/
extern bool game_running;

/********************************************************************
A matrix populated with values signifying whehter a space is occupied,
    empty, or a solid wall (border of playable area)
********************************************************************/
game_space* collision_map[GAME_ROWS][GAME_COLS];

/********************************************************************
The visual version of the game board, made out of strings
********************************************************************/
extern char* GAME_BOARD[];

#endif/********************************************************************
    Module: game_logic.h
    Author: Brennan Couturier

    Functions to manage movement, collisions, win/lose conditions
********************************************************************/

#ifndef GAME_LOGIC_H
#define GAME_LOGIC_H

#endif/********************************************************************
    Module: game_space.h
    Author: Brennan Couturier

    Functions to manipulate individual coordinates
********************************************************************/

#ifndef GAME_SPACE_H
#define GAME_SPACE_H

#include "../include/player.h"
#include "../include/caterpillar.h"
#include "../include/bullet.h"

/********************************************************************
A coordinate can be empty (nothing on it), solid (wall that player 
    can't go through), or is populated by the player, a bullet or 
    a caterpillar.
********************************************************************/
typedef enum collision_status_enum{
    empty,
    occupied
} collision_status;

/********************************************************************
Each coordinate has a status and 1 object on it.
********************************************************************/
typedef struct game_space_struct{
    int row;
    int col;
    collision_status status;
    player* _player;
    caterpillar* _caterpillar;
    bullet* _bullet;
} game_space;

/********************************************************************
Create a square to populate the collision matrix with
********************************************************************/
game_space* create_game_space(collision_status status, int row, int col);

/********************************************************************
Free a given game space. Assumes the player/bullet/caterpillar
    has been freed already, so it just sets them to NULL
********************************************************************/
void delete_game_space(game_space* to_delete);

/********************************************************************
Populate the collision matrix
********************************************************************/
void fill_collision_map();

/********************************************************************
Frees every game space
********************************************************************/
void clear_collision_map();

#endif/********************************************************************
    Module: lists.h
    Author: Brennan Couturier

    Functions to manage bullet/caterpillar/thread linked lists
********************************************************************/

#ifndef LISTS_H
#define LISTS_H

#include <pthread.h>

#include "caterpillar.h"
#include "bullet.h"

/********************************************************************
Keep track of how many threads that need to be joined at the end
********************************************************************/
typedef struct thread_node_struct{
    pthread_t _thread;
    int custom_id;
    struct thread_node_struct* next;
} thread_node;

/********************************************************************
Keep track of how many caterpillars are currently in play
********************************************************************/
typedef struct caterpillar_node_struct{
    caterpillar* _caterpillar;
    struct caterpillar_node_struct* next;
} caterpillar_node;

/********************************************************************
Keep track of how many bullets are currently in play
********************************************************************/
typedef struct bullet_node_struct{
    bullet* _bullet;
    struct bullet_node_struct* next;
} bullet_node;


/********************************************************************
Adds a caterpillar to the end of the linked list
    returns 0 upon successful addition
********************************************************************/
int add_caterpillar_to_list(caterpillar* to_add);

/********************************************************************
Remove a given caterpillar from its list
    Compares the address of to_remove with the caterpillars in the
    list. If one matches, remove it and return.
    
    Returns 0 upon successful deletion
    Returns -1 if to_remove wasn't in the list
********************************************************************/
int remove_caterpillar_from_list(caterpillar* to_remove);

/********************************************************************
Print the caterpillar list using its global head variable
********************************************************************/
void print_caterpillar_list();

/********************************************************************
Frees every caterpillar in the list
********************************************************************/
void free_caterpillar_list();

/********************************************************************
Adds a bullet node to the end of the list
********************************************************************/
int add_bullet_to_list(bullet* to_add);

/********************************************************************
Remove a given bullet from its list
********************************************************************/
int remove_bullet_from_list(bullet* to_remove);

/********************************************************************
Print the bullet list using its global head variable
********************************************************************/
void print_bullet_list();

/********************************************************************
Frees every bullet in the list
********************************************************************/
void free_bullet_list();

/********************************************************************
Adds a thread node to the end of the list
********************************************************************/
int add_thread_to_list(pthread_t thread, int custom_thread_id);

/********************************************************************
Remove a given thread from its list. Assumes the thread has been 
    joined already when it frees the node.
********************************************************************/
int remove_thread_from_list(pthread_t thread);

/********************************************************************
Print the addresses of the thread in the thread list using its global 
    head variable
********************************************************************/
void print_thread_list();

/********************************************************************
Joins each thread in the list and frees the nodes
********************************************************************/
void join_free_thread_list();

#endif/********************************************************************
    Module: player.h
    Author: Brennan Couturier

    Functions to manage player data
********************************************************************/

#ifndef PLAYER_H
#define PLAYER_H

#define PLAYER_ANIM_FRAMES 2
#define PLAYER_ANIM_TICKS 50
#define PLAYER_WIDTH 3
#define PLAYER_HEIGHT 1

#include <stdbool.h>
#include <pthread.h>

/********************************************************************
Keep track of the player's current status, whether they're alive and
    moving, just got hit and are respawing, or are out of lives.
********************************************************************/
typedef enum player_state_enum{
    ALIVE,
    DEAD,
    GAMEOVER
} player_state;

/********************************************************************
Keep track of useful player info
    start_col, start_row: Where the player spawned
    state: The player's current status
    running: Whether the player can move/shoot/get hit
    lives: How many lives the player has left
    col, row: The current location of the player
    anim_frame: What animation frame is currently being drawn
    score: The player's current score
********************************************************************/
typedef struct player_struct{
    int start_col;
    int start_row;

    player_state state;

    bool running;
    int lives;
    int col;
    int row;
    int anim_frame;
    int score;
} player;

/********************************************************************
Allocate a player struct on the heap, assigns that pointer to
    the global variable player_ref instead of returning it
********************************************************************/
void create_player(int start_row, int start_col, int num_lives);

/********************************************************************
Start the player thread, initialize its mutex
********************************************************************/
void spawn_player(player* p);

/********************************************************************
Draw a blank where the player currently is, then draw the player at
    the new location
********************************************************************/
void move_player(player* p, int dest_col, int dest_row);

/********************************************************************
Called when the player gets hit by an enemy bullet, remove one life,
    end game if all the lives are gone
********************************************************************/
void damage_player(player* p);

#endif/********************************************************************
    Module: threads_mutexes.h
    Author: Brennan Couturier

    All the threads and mutexes available globally
********************************************************************/

#include <pthread.h>

/********************************************************************
All the main threads that are needed. The caterpillar and bullet 
    threads are made on the fly and are assigned to each individual
    bullet/caterpillar. They are not global variables like these.
********************************************************************/
pthread_t player_animation_thread;
pthread_t player_movement_thread;
pthread_t keyboard_thread;
pthread_t screen_thread;
pthread_t upkeep_thread;
pthread_t caterpillar_spawn_thread;
pthread_t input_thread;

/********************************************************************
All the mutexes that are needed. Each caterpillar/bullet has its own
    mutex, assigned when the bullet/caterpillar is made
********************************************************************/
extern pthread_mutex_t player_mutex;
extern pthread_mutex_t screen_mutex;
extern pthread_mutex_t caterpillar_list_mutex;
extern pthread_mutex_t bullet_list_mutex;
extern pthread_mutex_t thread_list_mutex;
extern pthread_mutex_t game_cond_mutex;
extern pthread_mutex_t game_running_mutex;
extern pthread_mutex_t collision_map_mutex;

/********************************************************************
Function that starts the game up then sleeps on a condition variable
********************************************************************/
void run_game();
/********************************************************************
    Module: thread_wrappers.h
    Author: Brennan Couturier

    Functions to manage and error check threads
********************************************************************/

#ifndef THREAD_WRAPPERS_H
#define THREAD_WRAPPERS_H

#endif/********************************************************************
    Module: bullet.c
    Author: Brennan Couturier

    Functions to manage bullet data
********************************************************************/
#include <stdio.h>
#include <stdlib.h>
#include <pthread.h>

#include "../include/bullet.h"

char* PLAYER_BULLET_GRAPHIC[BULLET_ANIM_FRAMES][BULLET_HEIGHT] = {
    {"'"}
};

bullet* create_bullet(){
    bullet* to_return = malloc(sizeof(bullet));
    if(to_return == NULL){
        //TODO: Create error handlers
        fprintf(stderr, "Error in create_bullet() : Could not allocate space for bullet\n");
        exit(EXIT_FAILURE);
    }
    return to_return;
}/********************************************************************
    Module: caterpillar.c
    Author: Brennan Couturier

    Functions to manage caterpillar data
********************************************************************/
#include <stdio.h>
#include <stdlib.h>

#include "../include/caterpillar.h"

caterpillar* create_caterpillar(int start_col, int start_row, int size){
    caterpillar* to_return = malloc(sizeof(caterpillar));
    if(to_return == NULL){
        //TODO: Create error handlers
        fprintf(stderr, "Error in create_caterpillar() : Could not allocate space for caterpillar\n");
        exit(EXIT_FAILURE);
    }

    to_return->col = start_col;
    to_return->row = start_row;
    to_return->size = size;
    return to_return;
}/**********************************************************************
  Module: console.c
  Author: Daniel Rea

  Purpose: see console.h

  NOTES: none
**********************************************************************/

#include "console.h"
#include <curses.h>
#include <string.h>
#include <time.h>        /*for nano sleep */


static int CON_WIDTH, CON_HEIGHT;
static int consoleLock = false;
static int MAX_STR_LEN = 256; /* for strlen checking */

/* Local functions */

static bool checkConsoleSize(int reqHeight, int reqWidth) 
{

	if ( (reqWidth > COLS) || (reqHeight > LINES) ) 
 	{
    		fprintf(stderr, "\n\n\rSorry, your window is only %ix%i. \n\r%ix%i is required. Sorry.\n\r", COLS, LINES, reqWidth, reqHeight);
    		return (false);
  	}

  return(true);
}

bool consoleInit(int height, int width, char *image[])  /* assumes image height/width is same as height param */
{
	bool status;

	initscr();
	crmode();
	noecho();
	clear();

	CON_HEIGHT = height;  CON_WIDTH = width;
	status = checkConsoleSize(CON_HEIGHT, CON_WIDTH);

	if (status) 
	{
		consoleDrawImage(0, 0, image, CON_HEIGHT);
		consoleRefresh();
	}

	return(status);
}

void consoleDrawImage(int row, int col, char *image[], int height) 
{
	int i, length;
	int newLeft, newRight, newOffset, newLength;

	if (consoleLock) return;

	newLeft  = col < 0 ? 0 : col;
	newOffset = col < 0 ? -col : 0;

	for (i = 0; i < height; i++) 
	{
		if (row+i < 0 || row+i >= CON_HEIGHT)
			continue;
		length = strnlen(image[i], MAX_STR_LEN);
		newRight = col+length >= CON_WIDTH ? CON_WIDTH-1 : col+length;
		newLength = newRight - newLeft + 1;
		if (newOffset >= length || newLength <= 0)
		  continue;

		if (mvaddnstr(row+i, newLeft, image[i]+newOffset, newLength) == ERR)
			fprintf(stderr, "ERROR drawing to screen"); /* smarter handling is needed */
	}
}

void consoleClearImage(int row, int col, int height, int width) 
{
	int i, j;
	if (consoleLock) return;

	if (col+width > CON_WIDTH)
		width = CON_WIDTH-col;
	if (col < 0) 
	{
		width += col; /* -= -col */
		col = 0;
	}

	if (width < 1 || col >= CON_WIDTH) /* nothing to clear */
		return;

	for (i = 0; i < height; i++) 
	{
		if (row+i < 0 || row+i >= CON_HEIGHT)
			continue;
		move(row+i, col);
		for (j = 0; j < width; j++)
	    		addch(' ');
	}
}

void consoleRefresh(void)
{
	if (!consoleLock) 
	{
	    move(LINES-1, COLS-1);
	    refresh();
	}
}

void consoleFinish(void) 
{
    endwin();
}

void putBanner(const char *str) 
{
  if (consoleLock) return;
  int len;

  len = strnlen(str,MAX_STR_LEN);
  
  move (CON_HEIGHT/2, (CON_WIDTH-len)/2);
  addnstr(str, len);

  consoleRefresh();
}

void putString(char *str, int row, int col, int maxlen) 
{
  if (consoleLock) return;
  move(row, col);
  addnstr(str, maxlen);
}


/* setup to work in USECS, reduces risk of overflow */
/* 10000 usec = 10 ms, or 100fps */
#define TIMESLICE_USEC 10000
#define TIME_USECS_SIZE 1000000
#define USEC_TO_NSEC 1000  
struct timespec getTimeout(int ticks) 
{
  struct timespec rqtp;

  /* work in usecs at first */
  rqtp.tv_nsec = TIMESLICE_USEC * ticks;

  /* handle usec overflow */
  rqtp.tv_sec = rqtp.tv_nsec / TIME_USECS_SIZE;
  rqtp.tv_nsec %= TIME_USECS_SIZE;

  rqtp.tv_nsec *= USEC_TO_NSEC;  /*convert to nsecs */
  return rqtp;
}

void sleepTicks(int ticks) 
{

  if (ticks <= 0)
    return;

  struct timespec rqtp = getTimeout(ticks);
  nanosleep(&rqtp, NULL);
}

#define FINAL_PAUSE 2 
void finalKeypress() 
{
	flushinp();
	sleepTicks(FINAL_PAUSE);
    	move(LINES-1, COLS-1);
	getch(); /* wait for user to press a character, blocking. */
}

void disableConsole(int disabled) 
{
	consoleLock = disabled;
}
/********************************************************************
    Module: game_globals.c
    Author: Brennan Couturier

    Variables used throughout the program
********************************************************************/

#include <stdlib.h>

#include "../include/game_globals.h"
#include "../include/lists.h"
#include "../include/player.h"
#include "../include/game_space.h"

caterpillar_node* caterpillar_list_head = NULL;
bullet_node* bullet_list_head = NULL;
thread_node* thread_list_head = NULL;
player* player_ref = NULL;

bool game_running = false;

char* PLAYER_GRAPHIC[PLAYER_ANIM_FRAMES][PLAYER_HEIGHT] = {
    {"<^>"},
    {"< >"}
};

/**** DIMENSIONS MUST MATCH the ROWS/COLS */
char* GAME_BOARD[] = {
"",
"=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-centipiede!=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"",
"",
"",
"",
"",
"",
"", 
"" };/********************************************************************
    Module: game_space.c
    Author: Brennan Couturier

    Functions to manipulate individual coordinates
********************************************************************/

#include <stdio.h>
#include <stdlib.h>

#include "../include/game_space.h"
#include "../include/game_globals.h"
#include "../include/player.h"
#include "../include/caterpillar.h"
#include "../include/bullet.h"

game_space* create_game_space(collision_status status_in, int row_in, int col_in){
    game_space* to_return = malloc(sizeof(game_space));
    if(to_return == NULL){
        //TODO: create error handlers
        fprintf(stderr, "Error in create_game_space() : Could not allocate space for game space\n");
        exit(EXIT_FAILURE);
    }

    to_return->row = row_in;
    to_return->col = col_in;
    to_return->status = status_in;
    to_return->_bullet = NULL;
    to_return->_caterpillar = NULL;
    to_return->_player = NULL;

    return to_return;
}

void delete_game_space(game_space* to_delete){
    to_delete->_player = NULL;
    to_delete->_bullet = NULL;
    to_delete->_caterpillar = NULL;

    free(to_delete);
}

void fill_collision_map(){
    int i;
    int j;
    int top_player_line_y_coord = 16;
    collision_status status;

    //initialize them all as NULL
    for(i = 0; i < GAME_ROWS; i++){
        for(j = 0; j < GAME_COLS; j++){
            collision_map[i][j] = NULL;
        }
    }

    for(i = 0; i < GAME_ROWS; i++){
        for(j = 0; j < GAME_COLS; j++){
            //-1 is an invalid value, just to make it so the boundaries
            //  do not get assigned a game space
            if(j == 0 || j == (GAME_COLS - PLAYER_WIDTH)){
                status = -1;
            }else if(i == top_player_line_y_coord){
                status = -1;
            }else if(i == GAME_ROWS - 1){
                status = -1;
            }else if(i == 1){
                status = -1;
            }else{
                status = empty;
            }

            if(status == empty){
                //Create game space with that status
                game_space* to_add = create_game_space(status, i, j);

                collision_map[i][j] = to_add;
            }
            
        }
    }
}

void clear_collision_map(){
    int i;
    int j;

    for(i = 0; i < GAME_ROWS; i++){
        for(j = 0; j < GAME_COLS; j++){
            if(collision_map[i][j] != NULL){
                delete_game_space(collision_map[i][j]);
            }
        }
    }
}/********************************************************************
    Module: lists.c
    Author: Brennan Couturier

    Functions to manage bullet/caterpillar/thread linked lists
********************************************************************/

#include <stdio.h>
#include <stdlib.h>
#include <pthread.h>

#include "../include/lists.h"
#include "../include/threads_mutexes.h"
#include "../include/game_globals.h"

/********************************************************************
Caterpillar list functions
********************************************************************/

caterpillar_node* create_caterpillar_node(caterpillar* caterpillar_in){

    caterpillar_node* to_return = malloc(sizeof(caterpillar_node));
    if(to_return == NULL){
        //TODO: Create error handlers
        fprintf(stderr, "Error in create_caterpillar_node() : Could not allocate space for caterpillar node\n");
        exit(EXIT_FAILURE);
    }
    to_return->_caterpillar = caterpillar_in;
    to_return->next = NULL;

    return to_return;
}

int add_caterpillar_to_list(caterpillar* in){
    caterpillar_node* to_add = create_caterpillar_node(in);

    pthread_mutex_lock(&caterpillar_list_mutex);

    //if the list is empty, just make head the new node
    if(caterpillar_list_head == NULL){
        caterpillar_list_head = to_add;
        pthread_mutex_unlock(&caterpillar_list_mutex);
        return 0;
    }

    //otherwise, add c to the end of the list
    caterpillar_node* curr = caterpillar_list_head;
    while(curr->next != NULL){
        curr = curr->next;
    }
    curr->next = to_add;

    pthread_mutex_unlock(&caterpillar_list_mutex);

    return 0;
}

int remove_caterpillar_from_list(caterpillar* to_remove){
    pthread_mutex_lock(&caterpillar_list_mutex);
    caterpillar_node* curr = caterpillar_list_head;
    caterpillar_node* prev = curr;
    while(curr->next != NULL){
        curr = curr->next;
        if(prev->_caterpillar == to_remove){
            //The addresses match, they are the same caterpillar
            if(prev == caterpillar_list_head){
                //removing the first item
                caterpillar_list_head = prev->next;
                free(prev->_caterpillar);
                free(prev);
                prev = NULL;
                pthread_mutex_unlock(&caterpillar_list_mutex);
                return 0;
            }
        }else if(curr->_caterpillar == to_remove){
            //Remove curr, make prev->next skip it
            prev->next = curr->next;
            free(curr->_caterpillar);
            free(curr);
            curr = NULL;
            pthread_mutex_unlock(&caterpillar_list_mutex);
            return 0;
        }
        prev = curr;
    }
    pthread_mutex_unlock(&caterpillar_list_mutex);
    return -1;
}

void print_caterpillar_list(){

    pthread_mutex_lock(&caterpillar_list_mutex);
    caterpillar_node* curr = caterpillar_list_head;
    while(curr != NULL){
        fprintf(stdout, "<%p>\tcol %d\trow %d\tsize %d\n",
                (curr->_caterpillar),
                curr->_caterpillar->col,
                curr->_caterpillar->row,
                curr->_caterpillar->size);
        curr = curr->next;
    }
    pthread_mutex_unlock(&caterpillar_list_mutex);
}

void free_caterpillar_list(){
    pthread_mutex_lock(&caterpillar_list_mutex);
    caterpillar_node* curr = caterpillar_list_head;
    caterpillar_node* prev = curr;
    while(curr != NULL){
        curr = curr->next;
        free(prev->_caterpillar);
        free(prev);
        prev = curr;
    }
    pthread_mutex_unlock(&caterpillar_list_mutex);
}

/********************************************************************
Bullet list functions
********************************************************************/

bullet_node* create_bullet_node(bullet* bullet_in){

    bullet_node* to_return = malloc(sizeof(bullet_node));
    if(to_return == NULL){
        //TODO: Create error handlers
        fprintf(stderr, "Error in create_bullet_node() : Could not allocate space for bullet node\n");
        exit(EXIT_FAILURE);
    }
    to_return->_bullet = bullet_in;
    to_return->next = NULL;

    return to_return;
}

int add_bullet_to_list(bullet* in){
    bullet_node* to_add = create_bullet_node(in);

    pthread_mutex_lock(&bullet_list_mutex);

    //if the list is empty, just make head the new node
    if(bullet_list_head == NULL){
        bullet_list_head = to_add;
        pthread_mutex_unlock(&bullet_list_mutex);
        return 0;
    }

    //otherwise, add c to the end of the list
    bullet_node* curr = bullet_list_head;
    while(curr->next != NULL){
        curr = curr->next;
    }
    curr->next = to_add;

    pthread_mutex_unlock(&bullet_list_mutex);

    return 0;
}

int remove_bullet_from_list(bullet* to_remove){
    pthread_mutex_lock(&bullet_list_mutex);
    bullet_node* curr = bullet_list_head;
    bullet_node* prev = curr;
    while(curr->next != NULL){
        curr = curr->next;
        if(prev->_bullet == to_remove){
            //The addresses match, they are the same bullet
            if(prev == bullet_list_head){
                //removing the first item
                bullet_list_head = prev->next;
                free(prev->_bullet);
                free(prev);
                prev = NULL;
                pthread_mutex_unlock(&bullet_list_mutex);
                return 0;
            }
        }else if(curr->_bullet == to_remove){
            //Remove curr, make prev->next skip it
            prev->next = curr->next;
            free(curr->_bullet);
            free(curr);
            curr = NULL;
            pthread_mutex_unlock(&bullet_list_mutex);
            return 0;
        }
        prev = curr;
    }
    pthread_mutex_unlock(&bullet_list_mutex);
    return -1;
}

void print_bullet_list(){

    pthread_mutex_lock(&bullet_list_mutex);
    bullet_node* curr = bullet_list_head;
    while(curr != NULL){
        fprintf(stdout, "<%p>\tcol %d\trow %d\n",
                (curr->_bullet),
                curr->_bullet->col,
                curr->_bullet->row);
        curr = curr->next;
    }
    pthread_mutex_unlock(&bullet_list_mutex);
}

void free_bullet_list(){
    pthread_mutex_lock(&bullet_list_mutex);
    bullet_node* curr = bullet_list_head;
    bullet_node* prev = curr;
    while(curr != NULL){
        curr = curr->next;
        free(prev->_bullet);
        free(prev);
        prev = curr;
    }
    pthread_mutex_unlock(&bullet_list_mutex);
}

/********************************************************************
Thread list functions
********************************************************************/

thread_node* create_thread_node(pthread_t thread_in, int id){
    thread_node* to_return = malloc(sizeof(thread_node));
    if(to_return == NULL){
        //TODO: Create error handlers
        fprintf(stderr, "Error in create_thread_node() : Could not allocate space for thread_node\n");
        exit(EXIT_FAILURE);
    }
    to_return->_thread = thread_in;
    to_return->custom_id = id;
    to_return->next = NULL;
    return to_return;
}

int add_thread_to_list(pthread_t in, int id){
    thread_node* to_add = create_thread_node(in, id);

    pthread_mutex_lock(&thread_list_mutex);

    //if the list is empty, just make head the new node
    if(thread_list_head == NULL){
        thread_list_head = to_add;
        pthread_mutex_unlock(&thread_list_mutex);
        return 0;
    }

    //otherwise, add c to the end of the list
    thread_node* curr = thread_list_head;
    while(curr->next != NULL){
        curr = curr->next;
    }
    curr->next = to_add;

    pthread_mutex_unlock(&thread_list_mutex);

    return 0;
}

int remove_thread_from_list(pthread_t to_remove){
    pthread_mutex_lock(&thread_list_mutex);
    thread_node* curr = thread_list_head;
    if(curr == NULL){
        fprintf(stderr, "List is empty\n");
        pthread_mutex_unlock(&thread_list_mutex);
        return -1;
    }
    thread_node* prev = curr;
    while(curr->next != NULL){
        curr = curr->next;
        if(pthread_equal(prev->_thread, to_remove) != 0){
            //The addresses match, they are the same thread
            if(prev == thread_list_head){
                //join the thread and remove the first item
                thread_list_head = prev->next;
                pthread_join(prev->_thread, NULL);
                //fprintf(stdout, "Joined <%d>\n", prev->custom_id);
                free(prev);
                prev = NULL;
                pthread_mutex_unlock(&thread_list_mutex);
                return 0;
            }
        }else if(pthread_equal(curr->_thread, to_remove) != 0){
            //Join curr->_thread, remove curr, make prev->next skip it
            pthread_join(curr->_thread, NULL);
            //fprintf(stdout, "Joined <%d>\n", curr->custom_id);
            prev->next = curr->next;
            free(curr);
            curr = NULL;
            pthread_mutex_unlock(&thread_list_mutex);
            return 0;
        }
        prev = curr;
    }
    pthread_mutex_unlock(&thread_list_mutex);
    return -1;
}

void print_thread_list(){

    pthread_mutex_lock(&thread_list_mutex);
    thread_node* curr = thread_list_head;
    while(curr != NULL){
        fprintf(stdout, "<%d>\n", curr->custom_id);
        curr = curr->next;
    }
    pthread_mutex_unlock(&thread_list_mutex);
}

#include <string.h>
void join_free_thread_list(){
    pthread_mutex_lock(&thread_list_mutex);
    thread_node* curr = thread_list_head;
    thread_node* prev = curr;
    while(curr != NULL){
        curr = curr->next;
        //fprintf(stdout, "Joining <%d>\n", prev->custom_id);
        int err = pthread_join(prev->_thread, NULL);
        if(err != 0){
            fprintf(stdout, "Error %s\n", strerror(err));
        }
        //fprintf(stdout, "Joined <%d>\n", prev->custom_id);
        free(prev);
        prev = curr;
    }
    pthread_mutex_unlock(&thread_list_mutex);
}/**********************************************************************
    Module: main.c
    Author: Brennan Couturier

    Operating Systems 1
**********************************************************************/

#include <stdlib.h>
#include <stdio.h>
#include <pthread.h>
#include <string.h>

#include "../include/threads_mutexes.h"

int main(){

    run_game();
    
    return 0;
}/********************************************************************
    Module: player.c
    Author: Brennan Couturier

    Functions to manage player data
********************************************************************/

#include <stdlib.h>
#include <stdio.h>
#include <stdbool.h>
#include <pthread.h>

#include "../include/player.h"
#include "../include/game_globals.h"

void create_player(int start_row_in, int start_col_in, int num_lives_in){
    player* to_return = malloc(sizeof(player));
    if(to_return == NULL){
        //TODO: Create error handlers
        fprintf(stderr, "Error in create_player() : Could not allocate space for player\n");
        exit(EXIT_FAILURE);
    }

    to_return->start_col = start_col_in;
    to_return->start_row = start_row_in;
    to_return->state = ALIVE;
    to_return->running = true;
    to_return->lives = num_lives_in;
    to_return->col = start_col_in;
    to_return->row = start_row_in;
    to_return->anim_frame = 0;
    to_return->score = 0;

    //assign this object to the global player variable
    player_ref = to_return;

    return;
}

/*
void reset_player(player* p){
    p->col = p->start_col;
    p->row = p->start_row;
    p->anim_frame = 0;
    p->state = ALIVE;
}
*/
/*
void redraw_player(player* p){
    //not thread safe
    pthread_mutex_lock(&screen_mutex);
    consoleClearImage(p->row, p->col, PLAYER_HEIGHT, PLAYER_WIDTH);
    consoleDrawImage(p->row, p->col, PLAYER_GRAPHIC[p->anim_frame], PLAYER_HEIGHT);
    pthread_mutex_unlock(&screen_mutex);
}
*//********************************************************************
    Module: threads_mutexes.c
    Author: Brennan Couturier

    All the threads and mutexes
********************************************************************/

#define SCREEN_SLEEP_TICKS 1

#define LIVES_DIGITS 9
#define SCORE_DIGITS 13
#define LIVES_COL 40
#define SCORE_COL 20

#include <pthread.h>
#include <stdlib.h>
#include <stdio.h>
#include <stdbool.h>
#include <string.h>
#include <curses.h>
#include <sys/select.h>

#include "../include/threads_mutexes.h"
#include "../include/game_globals.h"
#include "../include/console.h"
#include "../include/lists.h"
#include "../include/player.h"
#include "../include/bullet.h"

pthread_mutex_t player_mutex = PTHREAD_MUTEX_INITIALIZER;
pthread_mutex_t screen_mutex = PTHREAD_MUTEX_INITIALIZER;
pthread_mutex_t caterpillar_list_mutex = PTHREAD_MUTEX_INITIALIZER;
pthread_mutex_t bullet_list_mutex = PTHREAD_MUTEX_INITIALIZER;
pthread_mutex_t thread_list_mutex = PTHREAD_MUTEX_INITIALIZER;
pthread_mutex_t game_cond_mutex = PTHREAD_MUTEX_INITIALIZER;
pthread_mutex_t game_running_mutex = PTHREAD_MUTEX_INITIALIZER;
pthread_mutex_t collision_map_mutex = PTHREAD_MUTEX_INITIALIZER;

//Local input buffer mutex
pthread_mutex_t input_buffer_mutex = PTHREAD_MUTEX_INITIALIZER;

//Input buffer, local to this entire file
char input_buffer;

/********************************************************************
Update the screen every tick
********************************************************************/
void* run_screen_thread(void* data){

    while(1){
        //Check if the game is still going
        pthread_mutex_lock(&game_running_mutex);
        if(!game_running){
            pthread_mutex_unlock(&game_running_mutex);
            return NULL;
        }
        pthread_mutex_unlock(&game_running_mutex);

        //refresh the screen
        pthread_mutex_lock(&screen_mutex);
        //
        consoleDrawImage(0, 0, GAME_BOARD, GAME_ROWS);
        consoleRefresh();
        //
        pthread_mutex_unlock(&screen_mutex);

        sleepTicks(SCREEN_SLEEP_TICKS);
    }
    
    return NULL;
}

/********************************************************************
Check statuses to see if the game needs to end
    Also, print score and lives
********************************************************************/
void* run_upkeep_thread(void* data){

    //space for up to 99 lives
    char lives_buffer[LIVES_DIGITS];

    //space for a 5 digit score
    char score_buffer[SCORE_DIGITS];

    while(1){
        //check if the game is still going
        pthread_mutex_lock(&game_running_mutex);
        if(!game_running){
            pthread_mutex_unlock(&game_running_mutex);
            //This thread handles signalling the main function to wake up
            pthread_cond_signal(&game_cond);
            return NULL;
        }
        pthread_mutex_unlock(&game_running_mutex);

        /*
        pthread_mutex_lock(&player_mutex);
        pthread_mutex_lock(&screen_mutex);
        pthread_mutex_lock(&collision_map_mutex);
        //
        char buffer[65];
        if(collision_map[player_ref->row][player_ref->col] == NULL){
            snprintf(buffer, 65, "collision_map[%d, %d] : NULL\nplayer[%d, %d]",
                            player_ref->row, player_ref->col,
                            player_ref->row, player_ref->col);
        }else{
            snprintf(buffer, 65, "collision_map[%d, %d] : %p\nplayer[%d, %d]",
                            player_ref->row, player_ref->col, 
                            collision_map[player_ref->row][player_ref->col]->_player,
                            player_ref->row, player_ref->col);
        }
        putString(buffer, 20, 0, 65);
        //
        pthread_mutex_unlock(&collision_map_mutex);
        pthread_mutex_unlock(&screen_mutex);
        pthread_mutex_unlock(&player_mutex);
        */

        //Print score and lives
        pthread_mutex_lock(&player_mutex);
        pthread_mutex_lock(&screen_mutex);
        //
        snprintf(lives_buffer, LIVES_DIGITS, "Lives: %d", player_ref->lives);
        snprintf(score_buffer, SCORE_DIGITS, "Score: %05d", player_ref->score); //print score in 5 digits always

        putString(lives_buffer, 0, LIVES_COL, LIVES_DIGITS);
        putString(score_buffer, 0, SCORE_COL, SCORE_DIGITS);
        //
        pthread_mutex_unlock(&screen_mutex);
        pthread_mutex_unlock(&player_mutex);

    }

    return NULL;
}

/********************************************************************
Move the bullet up the screen until it hits a caterpillar or the
    top of the screen
********************************************************************/
void* run_player_bullet_thread(void* data){

    int new_row;

    bullet* _bullet = (bullet*)data;
    
    pthread_mutex_lock(&player_mutex);
    _bullet->col = (player_ref->col) + (int)(PLAYER_WIDTH / 2);
    _bullet->row = player_ref->row - 1;
    pthread_mutex_unlock(&player_mutex);

    while(1){
        //check if the game is still going
        pthread_mutex_lock(&game_running_mutex);
        if(!game_running){
            pthread_mutex_unlock(&game_running_mutex);
            return NULL;
        }
        pthread_mutex_unlock(&game_running_mutex);

        //check collision_map and move player up
        new_row = _bullet->row - 1;
        if(new_row == 1){
            //bullet hit the top of the screen
            pthread_mutex_lock(&screen_mutex);
            consoleClearImage(_bullet->row, _bullet->col, BULLET_HEIGHT, BULLET_WIDTH);
            pthread_mutex_unlock(&screen_mutex);
            free(_bullet);
            return NULL;
        }

        //clear the bullet's current location
        pthread_mutex_lock(&screen_mutex);
        consoleClearImage(_bullet->row, _bullet->col, BULLET_HEIGHT, BULLET_WIDTH);
        pthread_mutex_unlock(&screen_mutex);

        //move the bullet up
        _bullet->row = new_row;

        pthread_mutex_lock(&screen_mutex);
        consoleDrawImage(_bullet->row, _bullet->col, PLAYER_BULLET_GRAPHIC[0], BULLET_HEIGHT);
        pthread_mutex_unlock(&screen_mutex);

        sleepTicks(SCREEN_SLEEP_TICKS * 7);
    }

    return NULL;
}

/********************************************************************
Clear the current player, calculate its next position, draw it
********************************************************************/
void* run_player_movement_thread(void* data){

    int x_offset = 0;
    int y_offset = 0;
    int new_x = 0;
    int new_y = 0;

    bullet* _b;

    while(1){

        //check if the game is still going
        pthread_mutex_lock(&game_running_mutex);
        if(!game_running){
            pthread_mutex_unlock(&game_running_mutex);
            return NULL;
        }
        pthread_mutex_unlock(&game_running_mutex);

        //Clear the player's current position
        pthread_mutex_lock(&player_mutex);
        pthread_mutex_lock(&screen_mutex);
        //
        consoleClearImage(player_ref->row, player_ref->col, PLAYER_HEIGHT, PLAYER_WIDTH);
        //
        pthread_mutex_unlock(&screen_mutex);
        pthread_mutex_unlock(&player_mutex);

        //check for cached input
        pthread_mutex_lock(&input_buffer_mutex);
        //
        switch(input_buffer){
            case 'a':
                x_offset = -1;
                break;
            case 's':
                y_offset = 1;
                break;
            case 'd':
                x_offset = 1;
                break;
            case 'w':
                y_offset = -1;
                break;
            case 32:
                //space
                //spawn bullet
                _b = create_bullet();
                add_bullet_to_list(_b);
                pthread_create(&(_b->thread), NULL, run_player_bullet_thread, (void*)_b);
                add_thread_to_list(_b->thread, 100);
                break;
            case 'q':
                pthread_mutex_lock(&game_running_mutex);
                game_running = false;
                pthread_mutex_unlock(&game_running_mutex);
            default:
                break;
        }
        input_buffer = 0;
        //
        pthread_mutex_unlock(&input_buffer_mutex);

        
        //Do collision checking and update player position
        pthread_mutex_lock(&player_mutex);
        pthread_mutex_lock(&screen_mutex);
        pthread_mutex_lock(&collision_map_mutex);
        //
        new_x = player_ref->col + x_offset;
        new_y = player_ref->row + y_offset;
        
        if(collision_map[new_y][new_x] != NULL){
            //Remove the player from the current game_space
            collision_map[player_ref->row][player_ref->col]->_player = NULL;

            player_ref->col += x_offset;
            player_ref->row += y_offset;

            //Add the player to the current game space
            collision_map[player_ref->row][player_ref->col]->_player = player_ref;
        }
        //
        pthread_mutex_unlock(&collision_map_mutex);
        pthread_mutex_unlock(&screen_mutex);
        pthread_mutex_unlock(&player_mutex);
        

        //Reset offset values
        x_offset = 0;
        y_offset = 0;
        
        //Draw the player at their new location
        pthread_mutex_lock(&player_mutex);
        pthread_mutex_lock(&screen_mutex);
        //
        consoleDrawImage(player_ref->row, player_ref->col, PLAYER_GRAPHIC[player_ref->anim_frame], PLAYER_HEIGHT);
        //
        pthread_mutex_unlock(&screen_mutex);
        pthread_mutex_unlock(&player_mutex);

        sleepTicks(SCREEN_SLEEP_TICKS * 7);
    }
    return NULL;
}

/********************************************************************
Update the player's anim_frame
********************************************************************/
void* run_player_animation_thread(void* data){
    

    while(1){
        //check if the game is still going
        pthread_mutex_lock(&game_running_mutex);
        if(!game_running){
            pthread_mutex_unlock(&game_running_mutex);
            return NULL;
        }
        pthread_mutex_unlock(&game_running_mutex);

        //Update animation
        pthread_mutex_lock(&player_mutex);
        //
        player_ref->anim_frame++;
        player_ref->anim_frame %= PLAYER_ANIM_FRAMES;
        //
        pthread_mutex_unlock(&player_mutex);

        sleepTicks(PLAYER_ANIM_TICKS);        
    }

    return NULL;
}

/********************************************************************
Move the bullet down the screen until it hits the or the
    bottom of the screen
********************************************************************/
void* run_caterpillar_bullet_thread(void* data){
    return NULL;
}

void* run_caterpillar_thread(void* data){

    return NULL;
}

/********************************************************************
Check for input, this thread blocks until a key is hit
********************************************************************/
void* run_input_thread(void* data){

    char key_pressed;

    while(1){
        //check if the game is still going
        pthread_mutex_lock(&game_running_mutex);
        if(!game_running){
            pthread_mutex_unlock(&game_running_mutex);
            return NULL;
        }
        pthread_mutex_unlock(&game_running_mutex);

        //block and wait until input
        fd_set rfds;
        struct timeval tv;
        int retval;
        //watch stdin (fd 0) for input
        FD_ZERO(&rfds);
        FD_SET(0, &rfds);

        tv.tv_sec = 1;
        tv.tv_usec = 0;

        retval = select(1, &rfds, NULL, NULL, &tv);

        if(retval == -1){
            //TODO: Create error handlers
            exit(EXIT_FAILURE);
        }else if(retval){
            key_pressed = getch();
        }

        //put the key into the input buffer
        pthread_mutex_lock(&input_buffer_mutex);
        input_buffer = key_pressed;
        key_pressed = 0;
        pthread_mutex_unlock(&input_buffer_mutex);

        //This thread doesn't sleep, instead it just blocks at getch()
    }
    return NULL;
}

void run_game(){

    //Try to initialize the console
    pthread_mutex_lock(&game_running_mutex);
    game_running = consoleInit(GAME_ROWS, GAME_COLS, GAME_BOARD);
    if(!game_running){
        pthread_mutex_unlock(&game_running_mutex);
        consoleFinish();
        return;
    }
    pthread_mutex_unlock(&game_running_mutex);

    //initalize collision map
    fill_collision_map();

    //make cursor invisible
    curs_set(0);

    //Initialize the input buffer
    input_buffer = 0;

    //Create the player using the constants in game_globals.h
    create_player(PLAYER_START_ROW, PLAYER_START_COL, PLAYER_START_LIVES);

    //Start the threads
    pthread_create(&screen_thread, NULL, run_screen_thread, (void*)NULL);
    pthread_create(&upkeep_thread, NULL, run_upkeep_thread, (void*)NULL);
    pthread_create(&player_animation_thread, NULL, run_player_animation_thread, (void*)NULL);
    pthread_create(&player_movement_thread, NULL, run_player_movement_thread, (void*)NULL);
    pthread_create(&input_thread, NULL, run_input_thread, (void*)NULL);

    //Add the threads to the list of threads to join
    add_thread_to_list(screen_thread, 0);
    add_thread_to_list(upkeep_thread, 1);
    add_thread_to_list(player_animation_thread, 2);
    add_thread_to_list(player_movement_thread, 3);
    add_thread_to_list(input_thread, 4);

    //let the threads do their thing, wait until we're woken up
    pthread_mutex_lock(&game_cond_mutex);
    pthread_cond_wait(&game_cond, &game_cond_mutex);

    //create_player allocates the player so free it here
    free(player_ref);

    //Adding a thread to the list allocates it, so free each thread
    // here. Also join each thread at the same time
    join_free_thread_list();

    consoleFinish();
    clear_collision_map();
    fprintf(stdout, "\nGame Over\n");

    return;
}